{
  "hash": "d94c069eacd9a8b947b823c497dbfc1e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Loops and Apply Functions in R\"\ndescription: \"Learn how to use loops and apply functions for efficient data processing in R\"\ndate: \"2025-03-30\"\ncategories: [basics, r-programming]\nimage: \"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/RStudio.png\"\nexecute:\n  echo: true\n  warning: false\n  message: false\n  eval: true\n---\n\n\n\n\n\n## Loops and Apply Functions in R\n\nR offers several methods to perform repetitive tasks through loops and the more efficient apply family of functions.\n\n### For Loops\n\nThe `for` loop iterates over elements in a sequence:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Basic for loop\nfor (i in 1:5) {\n  print(paste(\"Iteration:\", i))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Iteration: 1\"\n[1] \"Iteration: 2\"\n[1] \"Iteration: 3\"\n[1] \"Iteration: 4\"\n[1] \"Iteration: 5\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Looping through a vector\nfruits <- c(\"apple\", \"banana\", \"cherry\")\nfor (fruit in fruits) {\n  print(paste(\"I like\", fruit))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I like apple\"\n[1] \"I like banana\"\n[1] \"I like cherry\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### While Loops\n\nThe `while` loop continues until a condition becomes false:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Basic while loop\ncounter <- 1\nwhile (counter <= 5) {\n  print(paste(\"Count:\", counter))\n  counter <- counter + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Count: 1\"\n[1] \"Count: 2\"\n[1] \"Count: 3\"\n[1] \"Count: 4\"\n[1] \"Count: 5\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### Repeat Loops\n\nThe `repeat` loop runs indefinitely until a `break` statement:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Repeat loop with break\ncounter <- 1\nrepeat {\n  print(paste(\"Count:\", counter))\n  counter <- counter + 1\n  if (counter > 5) {\n    break\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Count: 1\"\n[1] \"Count: 2\"\n[1] \"Count: 3\"\n[1] \"Count: 4\"\n[1] \"Count: 5\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### Control Statements\n\nUse `break` to exit a loop and `next` to skip to the next iteration:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Using next to skip iterations\nfor (i in 1:10) {\n  if (i %% 2 == 0) {  # Skip even numbers\n    next\n  }\n  print(paste(\"Odd number:\", i))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Odd number: 1\"\n[1] \"Odd number: 3\"\n[1] \"Odd number: 5\"\n[1] \"Odd number: 7\"\n[1] \"Odd number: 9\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Apply Functions\n\nThe apply family of functions offers a more efficient and concise way to perform iterations in R.\n\n### `apply()` - For matrices and arrays\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a matrix\nmat <- matrix(1:9, nrow = 3)\nprint(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n\n```{.r .cell-code}\n# Apply sum function to each row\napply(mat, 1, sum)  # MARGIN=1 for rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 15 18\n```\n\n\n:::\n\n```{.r .cell-code}\n# Apply mean function to each column\napply(mat, 2, mean)  # MARGIN=2 for columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5 8\n```\n\n\n:::\n:::\n\n\n\n\n\n### `lapply()` - For lists, returns a list\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# List of vectors\nmy_list <- list(a = 1:3, b = 4:6, c = 7:9)\n\n# Apply function to each element\nlapply(my_list, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 6\n\n$b\n[1] 15\n\n$c\n[1] 24\n```\n\n\n:::\n:::\n\n\n\n\n\n### `sapply()` - Simplified apply, returns vector or matrix\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Same as above but with simplified output\nsapply(my_list, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c \n 6 15 24 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Using with a custom function\nsapply(my_list, function(x) x * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     a  b  c\n[1,] 2  8 14\n[2,] 4 10 16\n[3,] 6 12 18\n```\n\n\n:::\n:::\n\n\n\n\n\n### `vapply()` - Like sapply but with pre-specified output type\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Specify the output type for safety\nvapply(my_list, sum, FUN.VALUE = numeric(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c \n 6 15 24 \n```\n\n\n:::\n:::\n\n\n\n\n\n### `tapply()` - Apply function to subsets of a vector\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vector and grouping factor\nvalues <- c(1, 2, 3, 4, 5, 6, 7, 8)\ngroups <- c(\"A\", \"B\", \"A\", \"B\", \"A\", \"B\", \"A\", \"B\")\n\n# Calculate mean by group\ntapply(values, groups, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA B \n4 5 \n```\n\n\n:::\n:::\n\n\n\n\n\n### `mapply()` - Multivariate version of sapply\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Apply function to multiple lists in parallel\nmapply(sum, list(1:3), list(4:6), list(7:9))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 45\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create strings with multiple inputs\nmapply(paste, \"X\", 1:5, \"Y\", SIMPLIFY = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      X    <NA>    <NA>    <NA>    <NA> \n\"X 1 Y\" \"X 2 Y\" \"X 3 Y\" \"X 4 Y\" \"X 5 Y\" \n```\n\n\n:::\n:::\n\n\n\n\n\nThe apply family of functions is generally preferred over loops in R because they are: 1. More concise and readable 2. Often faster for large datasets 3. Aligned with R's vectorized approach to data processing\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}