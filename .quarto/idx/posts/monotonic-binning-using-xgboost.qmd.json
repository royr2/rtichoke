{"title":"Monotonic Binning Using XGBoost","markdown":{"yaml":{"title":"Monotonic Binning Using XGBoost","date":"2023-01-19","categories":["R","Credit Risk Analytics","XGBoost"],"image":"../images/monotonic.png","execute":{"echo":true,"warning":false,"message":false,"eval":true}},"headingText":"Prerequisites and Required Libraries","containsRefs":false,"markdown":"\n\nThis post focuses on how to implement monotonic binning, a method that groups variable values into bins where event rates demonstrate consistent monotonic behavior. This methodology is essential in credit risk modeling, providing significant advantages in two critical areas:\n\n1. **Enhanced Model Stability**: Monotonic relationships strengthen model robustness by reducing overfitting and ensuring reliable performance in production environments\n2. **Improved Interpretability**: Monotonic constraints facilitate clear explanations by maintaining logical, consistent relationships between predictors and outcomes\n\n\n```{r}\nlibrary(recipes)  # For data preprocessing\nlibrary(dplyr)    # For data manipulation\nlibrary(xgboost)  # For creating monotonic bins\nlibrary(ggplot2)  # For visualization\n```\n\n## Dataset Overview and Loading\n\nThis tutorial demonstrates the methodology using a sample from the Lending Club dataset, which provides comprehensive loan information including default indicators. \n\n```{r}\n# Load sample data from Lending Club dataset\nsample <- read.csv(\"https://bit.ly/42ypcnJ\")\n\n# Check dimensions of the dataset\ndim(sample)\n```\n\n## Creating a Binary Target Variable\n\nThe first step involves constructing a binary target variable that clearly identifies loan defaults. This variable will serve as our outcome throughout the binning process:\n\n```{r}\n# Define loan statuses that represent defaults\ncodes <- c(\"Charged Off\", \"Does not meet the credit policy. Status:Charged Off\")\n\n# Create binary target variable\nmodel_data <- sample %>%\n  mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))\n```\n\n## Data Preprocessing\n\nBefore proceeding, the dataset must be prepared through systematic preprocessing. This step ensures data quality and compatibility with the XGBoost implementation. The process utilizes the `recipes` package to:\n\n1. Filter and retain only numeric variables for analysis\n2. Apply median imputation to handle missing values appropriately\n\n```{r}\n# Create a recipe for preprocessing\nrec <- recipe(bad_flag ~ ., data = model_data) %>%\n  step_select(where(is.numeric)) %>%  # Keep only numeric variables\n  step_impute_median(all_predictors())  # Fill missing values with medians\n\n# Apply the preprocessing steps\nrec <- prep(rec, training = model_data)\ntrain <- bake(rec, new_data = model_data)\n```\n\n## Step 3: Exploratory Analysis of Variable Relationships\n\nIt is crucial to examine the raw relationship between predictor variables and the target outcome. This analysis provides insights into  underlying data patterns and validates the need for monotonic transformation. \n\nThis example analyzes the relationship between credit inquiries in the past 6 months and default rates:\n\n```{r}\n# Create dataframe with inquiries and default flag\ndata.frame(x = model_data$inq_last_6mths,\n           y = model_data$bad_flag) %>%\n  filter(x <= 5) %>%  # Focus on 0-5 inquiries for clarity\n  group_by(x) %>% \n  summarise(count = n(),  # Count observations in each group\n            events = sum(y)) %>%  # Count defaults in each group\n  mutate(pct = events/count) %>%  # Calculate default rate\n  ggplot(aes(x = factor(x), y = pct)) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"# of inquiries in past 6 months\", \n       y = \"Default rate\",\n       title = \"Default rate vs number of inquiries\")\n```\n\nWhile the data exhibits a general upward trend (indicating that increased inquiries correlate with higher default rates), the relationship lacks perfect monotonicity. This validates the necessity of the monotonic binning approach to establish consistent patterns.\n\n## Implementing Monotonic Binning with XGBoost\n\nThe implementation uses XGBoost's monotonicity constraints which enforces the model to generate splits that preserve a monotonic relationship with the target variable:\n\n```{r}\n# Train XGBoost model with monotonicity constraint\nmdl <- xgboost(\n  data = train %>%\n    select(inq_last_6mths) %>%  # Use only the inquiries variable\n    as.matrix(),  \n  label = train[[\"bad_flag\"]],  # Target variable\n  nrounds = 5,  # Number of boosting rounds\n  params = list(\n    booster = \"gbtree\",\n    objective = \"binary:logistic\",\n    monotone_constraints = 1,  # Force positive relationship\n    max_depth = 1  # Simple trees with single splits\n  ),\n  verbose = 0  # Suppress output\n)\n```\n\n## Extracting Split Points and Constructing Final Bins\n\nFollowing model training, the process extracts the optimal split points identified by XGBoost and utilizes them to construct the final  bin structure:\n\n```{r}\n# Extract split points from the model\nsplits <- xgb.model.dt.tree(model = mdl)  \n\n# Create bin boundaries including -Inf and Inf for complete coverage\ncuts <- c(-Inf, unique(sort(splits$Split)), Inf)\n\n# Create and visualize the monotonic bins\ndata.frame(target = train$bad_flag,\n           buckets = cut(train$inq_last_6mths, \n                         breaks = cuts, \n                         include.lowest = TRUE, \n                         right = TRUE)) %>% \n  group_by(buckets) %>%\n  summarise(total = n(),  # Count observations in each bin\n            events = sum(target == 1)) %>%  # Count defaults in each bin\n  mutate(pct = events/total) %>%  # Calculate default rate\n  ggplot(aes(x = buckets, y = pct)) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"Bins\", \n       y = \"Default rate\",\n       title = \"Monotonic Bins for Inquiries\")\n```\n\nThe default rates now demonstrate perfect monotonic behavior across all bins, creating a clearer and more interpretable relationship compared to the raw data.\n\n## Generalised Function\n\nTo enable implementation across multiple variables, a reusable function that encapsulates the entire monotonic binning workflow would be very useful here. **Note** the use of ranked correlation to identify the appropriate direction to be used inside the Xgboost call.\n\n```{r}\ncreate_bins <- function(var, outcome, max_depth = 10, plot = TRUE){\n  # Determine relationship direction automatically\n  corr <- cor(var, outcome, method = \"spearman\")\n  direction <- ifelse(corr > 0, 1, -1)  # 1 for positive, -1 for negative correlation\n  \n  # Build XGBoost model with appropriate monotonicity constraint\n  mdl <- xgboost(\n    verbose = 0,\n    data = as.matrix(var),\n    label = outcome,\n    nrounds = 100,  # Single round is sufficient for binning\n    params = list(objective = \"binary:logistic\",\n                  monotone_constraints = direction,  # Apply constraint based on correlation\n                  max_depth = max_depth))  # Control tree complexity\n  \n  # Extract and return split points\n  splits <- xgb.model.dt.tree(model = mdl)\n  cuts <- c(-Inf, sort(unique(splits$Split)), Inf)  # Include boundaries for complete coverage\n  \n  # Optionally visualize the bins\n  if(plot) {\n    data.frame(target = outcome,\n               buckets = cut(var, \n                            breaks = cuts, \n                            include.lowest = TRUE, \n                            right = TRUE)) %>% \n      group_by(buckets) %>%\n      summarise(total = n(),\n                events = sum(target == 1)) %>%\n      mutate(pct = events/total) %>%\n      ggplot(aes(x = buckets, y = pct)) + \n      geom_col() + \n      theme_minimal() + \n      labs(x = \"Bins\", \n           y = \"Default rate\",\n           title = \"Monotonic Bins\")\n  }\n  \n  return(cuts)  # Return the bin boundaries\n}\n\n# Example: Create monotonic bins for annual income\nincome_bins <- create_bins(\n  var = train$annual_inc,\n  outcome = train$bad_flag,\n  max_depth = 5\n)\n```\n","srcMarkdownNoYaml":"\n\nThis post focuses on how to implement monotonic binning, a method that groups variable values into bins where event rates demonstrate consistent monotonic behavior. This methodology is essential in credit risk modeling, providing significant advantages in two critical areas:\n\n1. **Enhanced Model Stability**: Monotonic relationships strengthen model robustness by reducing overfitting and ensuring reliable performance in production environments\n2. **Improved Interpretability**: Monotonic constraints facilitate clear explanations by maintaining logical, consistent relationships between predictors and outcomes\n\n## Prerequisites and Required Libraries\n\n```{r}\nlibrary(recipes)  # For data preprocessing\nlibrary(dplyr)    # For data manipulation\nlibrary(xgboost)  # For creating monotonic bins\nlibrary(ggplot2)  # For visualization\n```\n\n## Dataset Overview and Loading\n\nThis tutorial demonstrates the methodology using a sample from the Lending Club dataset, which provides comprehensive loan information including default indicators. \n\n```{r}\n# Load sample data from Lending Club dataset\nsample <- read.csv(\"https://bit.ly/42ypcnJ\")\n\n# Check dimensions of the dataset\ndim(sample)\n```\n\n## Creating a Binary Target Variable\n\nThe first step involves constructing a binary target variable that clearly identifies loan defaults. This variable will serve as our outcome throughout the binning process:\n\n```{r}\n# Define loan statuses that represent defaults\ncodes <- c(\"Charged Off\", \"Does not meet the credit policy. Status:Charged Off\")\n\n# Create binary target variable\nmodel_data <- sample %>%\n  mutate(bad_flag = ifelse(loan_status %in% codes, 1, 0))\n```\n\n## Data Preprocessing\n\nBefore proceeding, the dataset must be prepared through systematic preprocessing. This step ensures data quality and compatibility with the XGBoost implementation. The process utilizes the `recipes` package to:\n\n1. Filter and retain only numeric variables for analysis\n2. Apply median imputation to handle missing values appropriately\n\n```{r}\n# Create a recipe for preprocessing\nrec <- recipe(bad_flag ~ ., data = model_data) %>%\n  step_select(where(is.numeric)) %>%  # Keep only numeric variables\n  step_impute_median(all_predictors())  # Fill missing values with medians\n\n# Apply the preprocessing steps\nrec <- prep(rec, training = model_data)\ntrain <- bake(rec, new_data = model_data)\n```\n\n## Step 3: Exploratory Analysis of Variable Relationships\n\nIt is crucial to examine the raw relationship between predictor variables and the target outcome. This analysis provides insights into  underlying data patterns and validates the need for monotonic transformation. \n\nThis example analyzes the relationship between credit inquiries in the past 6 months and default rates:\n\n```{r}\n# Create dataframe with inquiries and default flag\ndata.frame(x = model_data$inq_last_6mths,\n           y = model_data$bad_flag) %>%\n  filter(x <= 5) %>%  # Focus on 0-5 inquiries for clarity\n  group_by(x) %>% \n  summarise(count = n(),  # Count observations in each group\n            events = sum(y)) %>%  # Count defaults in each group\n  mutate(pct = events/count) %>%  # Calculate default rate\n  ggplot(aes(x = factor(x), y = pct)) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"# of inquiries in past 6 months\", \n       y = \"Default rate\",\n       title = \"Default rate vs number of inquiries\")\n```\n\nWhile the data exhibits a general upward trend (indicating that increased inquiries correlate with higher default rates), the relationship lacks perfect monotonicity. This validates the necessity of the monotonic binning approach to establish consistent patterns.\n\n## Implementing Monotonic Binning with XGBoost\n\nThe implementation uses XGBoost's monotonicity constraints which enforces the model to generate splits that preserve a monotonic relationship with the target variable:\n\n```{r}\n# Train XGBoost model with monotonicity constraint\nmdl <- xgboost(\n  data = train %>%\n    select(inq_last_6mths) %>%  # Use only the inquiries variable\n    as.matrix(),  \n  label = train[[\"bad_flag\"]],  # Target variable\n  nrounds = 5,  # Number of boosting rounds\n  params = list(\n    booster = \"gbtree\",\n    objective = \"binary:logistic\",\n    monotone_constraints = 1,  # Force positive relationship\n    max_depth = 1  # Simple trees with single splits\n  ),\n  verbose = 0  # Suppress output\n)\n```\n\n## Extracting Split Points and Constructing Final Bins\n\nFollowing model training, the process extracts the optimal split points identified by XGBoost and utilizes them to construct the final  bin structure:\n\n```{r}\n# Extract split points from the model\nsplits <- xgb.model.dt.tree(model = mdl)  \n\n# Create bin boundaries including -Inf and Inf for complete coverage\ncuts <- c(-Inf, unique(sort(splits$Split)), Inf)\n\n# Create and visualize the monotonic bins\ndata.frame(target = train$bad_flag,\n           buckets = cut(train$inq_last_6mths, \n                         breaks = cuts, \n                         include.lowest = TRUE, \n                         right = TRUE)) %>% \n  group_by(buckets) %>%\n  summarise(total = n(),  # Count observations in each bin\n            events = sum(target == 1)) %>%  # Count defaults in each bin\n  mutate(pct = events/total) %>%  # Calculate default rate\n  ggplot(aes(x = buckets, y = pct)) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"Bins\", \n       y = \"Default rate\",\n       title = \"Monotonic Bins for Inquiries\")\n```\n\nThe default rates now demonstrate perfect monotonic behavior across all bins, creating a clearer and more interpretable relationship compared to the raw data.\n\n## Generalised Function\n\nTo enable implementation across multiple variables, a reusable function that encapsulates the entire monotonic binning workflow would be very useful here. **Note** the use of ranked correlation to identify the appropriate direction to be used inside the Xgboost call.\n\n```{r}\ncreate_bins <- function(var, outcome, max_depth = 10, plot = TRUE){\n  # Determine relationship direction automatically\n  corr <- cor(var, outcome, method = \"spearman\")\n  direction <- ifelse(corr > 0, 1, -1)  # 1 for positive, -1 for negative correlation\n  \n  # Build XGBoost model with appropriate monotonicity constraint\n  mdl <- xgboost(\n    verbose = 0,\n    data = as.matrix(var),\n    label = outcome,\n    nrounds = 100,  # Single round is sufficient for binning\n    params = list(objective = \"binary:logistic\",\n                  monotone_constraints = direction,  # Apply constraint based on correlation\n                  max_depth = max_depth))  # Control tree complexity\n  \n  # Extract and return split points\n  splits <- xgb.model.dt.tree(model = mdl)\n  cuts <- c(-Inf, sort(unique(splits$Split)), Inf)  # Include boundaries for complete coverage\n  \n  # Optionally visualize the bins\n  if(plot) {\n    data.frame(target = outcome,\n               buckets = cut(var, \n                            breaks = cuts, \n                            include.lowest = TRUE, \n                            right = TRUE)) %>% \n      group_by(buckets) %>%\n      summarise(total = n(),\n                events = sum(target == 1)) %>%\n      mutate(pct = events/total) %>%\n      ggplot(aes(x = buckets, y = pct)) + \n      geom_col() + \n      theme_minimal() + \n      labs(x = \"Bins\", \n           y = \"Default rate\",\n           title = \"Monotonic Bins\")\n  }\n  \n  return(cuts)  # Return the bin boundaries\n}\n\n# Example: Create monotonic bins for annual income\nincome_bins <- create_bins(\n  var = train$annual_inc,\n  outcome = train$bad_flag,\n  max_depth = 5\n)\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"zenburn","toc":true,"css":["../styles.css"],"output-file":"monotonic-binning-using-xgboost.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","editor":"source","theme":"sketchy","code-copy":true,"title":"Monotonic Binning Using XGBoost","date":"2023-01-19","categories":["R","Credit Risk Analytics","XGBoost"],"image":"../images/monotonic.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}